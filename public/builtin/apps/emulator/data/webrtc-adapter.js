// Webrtc adapter module from https://github.com/webrtcHacks/adapter
!(function (e) { if (typeof exports === 'object' && typeof module !== 'undefined')module.exports = e(); else if (typeof define === 'function' && define.amd)define([], e); else { let t; (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this).adapter = e(); } }(function () { return (function () { function e (t, r, n) { function i (a, s) { if (!r[a]) { if (!t[a]) { const c = typeof require === 'function' && require; if (!s && c) return c(a, !0); if (o) return o(a, !0); const p = Error("Cannot find module '" + a + "'"); throw p.code = 'MODULE_NOT_FOUND', p; } const d = r[a] = { exports: {} }; t[a][0].call(d.exports, function (e) { return i(t[a][1][e] || e); }, d, d.exports, e, t, r, n); } return r[a].exports; } for (var o = typeof require === 'function' && require, a = 0; a < n.length; a++)i(n[a]); return i; } return e; })()({ 1: [function (e, t, r) { 'use strict'; const n = (0, e('./adapter_factory.js').adapterFactory)({ window: typeof window === 'undefined' ? void 0 : window }); t.exports = n; }, { './adapter_factory.js': 2 }], 2: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }), r.adapterFactory = function () { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; const t = e.window; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: !0, shimFirefox: !0, shimSafari: !0 }; const n = i.log; const o = i.detectBrowser(t); const s = { browserDetails: o, commonShim: f, extractVersion: i.extractVersion, disableLog: i.disableLog, disableWarnings: i.disableWarnings, sdp: l }; switch (o.browser) { case 'chrome':if (!a || !a.shimPeerConnection || !r.shimChrome) { n('Chrome shim is not included in this adapter release.'); break; } if (o.version === null) { n('Chrome shim can not determine version, not shimming.'); break; }n('adapter.js shimming chrome.'), s.browserShim = a, f.shimAddIceCandidateNullOrEmpty(t, o), f.shimParameterlessSetLocalDescription(t, o), a.shimGetUserMedia(t, o), a.shimMediaStream(t, o), a.shimPeerConnection(t, o), a.shimOnTrack(t, o), a.shimAddTrackRemoveTrack(t, o), a.shimGetSendersWithDtmf(t, o), a.shimGetStats(t, o), a.shimSenderReceiverGetStats(t, o), a.fixNegotiationNeeded(t, o), f.shimRTCIceCandidate(t, o), f.shimConnectionState(t, o), f.shimMaxMessageSize(t, o), f.shimSendThrowTypeError(t, o), f.removeExtmapAllowMixed(t, o); break; case 'firefox':if (!c || !c.shimPeerConnection || !r.shimFirefox) { n('Firefox shim is not included in this adapter release.'); break; }n('adapter.js shimming firefox.'), s.browserShim = c, f.shimAddIceCandidateNullOrEmpty(t, o), f.shimParameterlessSetLocalDescription(t, o), c.shimGetUserMedia(t, o), c.shimPeerConnection(t, o), c.shimOnTrack(t, o), c.shimRemoveStream(t, o), c.shimSenderGetStats(t, o), c.shimReceiverGetStats(t, o), c.shimRTCDataChannel(t, o), c.shimAddTransceiver(t, o), c.shimGetParameters(t, o), c.shimCreateOffer(t, o), c.shimCreateAnswer(t, o), f.shimRTCIceCandidate(t, o), f.shimConnectionState(t, o), f.shimMaxMessageSize(t, o), f.shimSendThrowTypeError(t, o); break; case 'safari':if (!d || !r.shimSafari) { n('Safari shim is not included in this adapter release.'); break; }n('adapter.js shimming safari.'), s.browserShim = d, f.shimAddIceCandidateNullOrEmpty(t, o), f.shimParameterlessSetLocalDescription(t, o), d.shimRTCIceServerUrls(t, o), d.shimCreateOfferLegacy(t, o), d.shimCallbacksAPI(t, o), d.shimLocalStreamsAPI(t, o), d.shimRemoteStreamsAPI(t, o), d.shimTrackEventTransceiver(t, o), d.shimGetUserMedia(t, o), d.shimAudioContext(t, o), f.shimRTCIceCandidate(t, o), f.shimMaxMessageSize(t, o), f.shimSendThrowTypeError(t, o), f.removeExtmapAllowMixed(t, o); break; default:n('Unsupported browser!'); } return s; }; const n = e('./utils'); var i = h(n); const o = e('./chrome/chrome_shim'); var a = h(o); const s = e('./firefox/firefox_shim'); var c = h(s); const p = e('./safari/safari_shim'); var d = h(p); const u = e('./common_shim'); var f = h(u); const m = e('sdp'); var l = h(m); function h (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; } }, { './chrome/chrome_shim': 3, './common_shim': 6, './firefox/firefox_shim': 7, './safari/safari_shim': 10, './utils': 11, sdp: 12 }], 3: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = r.shimGetUserMedia = void 0; const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; const i = e('./getusermedia'); Object.defineProperty(r, 'shimGetUserMedia', { enumerable: !0, get: function () { return i.shimGetUserMedia; } }); const o = e('./getdisplaymedia'); Object.defineProperty(r, 'shimGetDisplayMedia', { enumerable: !0, get: function () { return o.shimGetDisplayMedia; } }), r.shimMediaStream = function (e) { e.MediaStream = e.MediaStream || e.webkitMediaStream; }, r.shimOnTrack = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || !e.RTCPeerConnection || 'ontrack' in e.RTCPeerConnection.prototype)s.wrapPeerConnectionEvent(e, 'track', function (e) { return e.transceiver || Object.defineProperty(e, 'transceiver', { value: { receiver: e.receiver } }), e; }); else { Object.defineProperty(e.RTCPeerConnection.prototype, 'ontrack', { get: function () { return this._ontrack; }, set: function (e) { this._ontrack && this.removeEventListener('track', this._ontrack), this.addEventListener('track', this._ontrack = e); }, enumerable: !0, configurable: !0 }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const r = this; return this._ontrackpoly || (this._ontrackpoly = function (t) { t.stream.addEventListener('addtrack', function (n) { let i = void 0; i = e.RTCPeerConnection.prototype.getReceivers ? r.getReceivers().find(function (e) { return e.track && e.track.id === n.track.id; }) : { track: n.track }; const o = new Event('track'); o.track = n.track, o.receiver = i, o.transceiver = { receiver: i }, o.streams = [t.stream], r.dispatchEvent(o); }), t.stream.getTracks().forEach(function (n) { let i = void 0; i = e.RTCPeerConnection.prototype.getReceivers ? r.getReceivers().find(function (e) { return e.track && e.track.id === n.id; }) : { track: n }; const o = new Event('track'); o.track = n, o.receiver = i, o.transceiver = { receiver: i }, o.streams = [t.stream], r.dispatchEvent(o); }); }, this.addEventListener('addstream', this._ontrackpoly)), t.apply(this, arguments); }; } }, r.shimGetSendersWithDtmf = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && !('getSenders' in e.RTCPeerConnection.prototype) && 'createDTMFSender' in e.RTCPeerConnection.prototype) { const t = function (e, t) { return { track: t, get dtmf () { return void 0 === this._dtmf && (t.kind === 'audio' ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf; }, _pc: e }; }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice(); }; const r = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, n) { let i = r.apply(this, arguments); return i || (i = t(this, e), this._senders.push(i)), i; }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { i.apply(this, arguments); const t = this._senders.indexOf(e); t !== -1 && this._senders.splice(t, 1); }; } const o = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { const r = this; this._senders = this._senders || [], o.apply(this, [e]), e.getTracks().forEach(function (e) { r._senders.push(t(r, e)); }); }; const a = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { const t = this; this._senders = this._senders || [], a.apply(this, [e]), e.getTracks().forEach(function (e) { const r = t._senders.find(function (t) { return t.track === e; }); r && t._senders.splice(t._senders.indexOf(r), 1); }); }; } else if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && 'getSenders' in e.RTCPeerConnection.prototype && 'createDTMFSender' in e.RTCPeerConnection.prototype && e.RTCRtpSender && !('dtmf' in e.RTCRtpSender.prototype)) { const s = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { const e = this; const t = s.apply(this, []); return t.forEach(function (t) { return t._pc = e; }), t; }, Object.defineProperty(e.RTCRtpSender.prototype, 'dtmf', { get: function () { return void 0 === this._dtmf && (this.track.kind === 'audio' ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf; } }); } }, r.shimGetStats = function (e) { if (e.RTCPeerConnection) { const t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const e = this; const r = Array.prototype.slice.call(arguments); const n = r[0]; const i = r[1]; const o = r[2]; if (arguments.length > 0 && typeof n === 'function') return t.apply(this, arguments); if (t.length === 0 && (arguments.length === 0 || typeof n !== 'function')) return t.apply(this, []); const a = function (e) { const t = {}; return e.result().forEach(function (e) { const r = { id: e.id, timestamp: e.timestamp, type: { localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }[e.type] || e.type }; e.names().forEach(function (t) { r[t] = e.stat(t); }), t[r.id] = r; }), t; }; const s = function (e) { return new Map(Object.keys(e).map(function (t) { return [t, e[t]]; })); }; if (arguments.length >= 2) { const c = function (e) { i(s(a(e))); }; return t.apply(this, [c, n]); } return new Promise(function (r, n) { t.apply(e, [function (e) { r(s(a(e))); }, n]); }).then(i, o); }; } }, r.shimSenderReceiverGetStats = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver) { if (!('getStats' in e.RTCRtpSender.prototype)) { const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const e = this; const r = t.apply(this, []); return r.forEach(function (t) { return t._pc = e; }), r; }); const r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { const e = r.apply(this, arguments); return e._pc = this, e; }), e.RTCRtpSender.prototype.getStats = function () { const e = this; return this._pc.getStats().then(function (t) { return s.filterStats(t, e.track, !0); }); }; } if (!('getStats' in e.RTCRtpReceiver.prototype)) { const i = e.RTCPeerConnection.prototype.getReceivers; i && (e.RTCPeerConnection.prototype.getReceivers = function () { const e = this; const t = i.apply(this, []); return t.forEach(function (t) { return t._pc = e; }), t; }), s.wrapPeerConnectionEvent(e, 'track', function (e) { return e.receiver._pc = e.srcElement, e; }), e.RTCRtpReceiver.prototype.getStats = function () { const e = this; return this._pc.getStats().then(function (t) { return s.filterStats(t, e.track, !1); }); }; } if ('getStats' in e.RTCRtpSender.prototype && 'getStats' in e.RTCRtpReceiver.prototype) { const o = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { const t = arguments[0]; let r = void 0; let n = void 0; let i = void 0; return (this.getSenders().forEach(function (e) { e.track === t && (r ? i = !0 : r = e); }), this.getReceivers().forEach(function (e) { return e.track === t && (n ? i = !0 : n = e), e.track === t; }), i || r && n) ? Promise.reject(new DOMException('There are more than one sender or receiver for the track.', 'InvalidAccessError')) : r ? r.getStats() : n ? n.getStats() : Promise.reject(new DOMException('There is no sender or receiver for the track.', 'InvalidAccessError')); } return o.apply(this, arguments); }; } } }, r.shimAddTrackRemoveTrackWithNative = p, r.shimAddTrackRemoveTrack = function (e, t) { if (e.RTCPeerConnection) { if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return p(e); const r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { const e = this; const t = r.apply(this); return this._reverseStreams = this._reverseStreams || {}, t.map(function (t) { return e._reverseStreams[t.id]; }); }; const n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (t) { const r = this; if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(function (e) { if (r.getSenders().find(function (t) { return t.track === e; })) throw new DOMException('Track already exists.', 'InvalidAccessError'); }), !this._reverseStreams[t.id]) { const i = new e.MediaStream(t.getTracks()); this._streams[t.id] = i, this._reverseStreams[i.id] = t, t = i; }n.apply(this, [t]); }; const i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]; }, e.RTCPeerConnection.prototype.addTrack = function (t, r) { const n = this; if (this.signalingState === 'closed') throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", 'InvalidStateError'); const i = [].slice.call(arguments, 1); if (i.length !== 1 || !i[0].getTracks().find(function (e) { return e === t; })) throw new DOMException('The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.', 'NotSupportedError'); if (this.getSenders().find(function (e) { return e.track === t; })) throw new DOMException('Track already exists.', 'InvalidAccessError'); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; const o = this._streams[r.id]; if (o)o.addTrack(t), Promise.resolve().then(function () { n.dispatchEvent(new Event('negotiationneeded')); }); else { const a = new e.MediaStream([t]); this._streams[r.id] = a, this._reverseStreams[a.id] = r, this.addStream(a); } return this.getSenders().find(function (e) { return e.track === t; }); }, ['createOffer', 'createAnswer'].forEach(function (t) { const r = e.RTCPeerConnection.prototype[t]; const n = c({}, t, function () { const e = this; const t = arguments; const n = arguments.length && typeof arguments[0] === 'function'; return n ? r.apply(this, [function (r) { const n = s(e, r); t[0].apply(null, [n]); }, function (e) { t[1] && t[1].apply(null, e); }, arguments[2]]) : r.apply(this, arguments).then(function (t) { return s(e, t); }); }); e.RTCPeerConnection.prototype[t] = n[t]; }); const o = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { let e, t, r; return arguments.length && arguments[0].type ? (arguments[0] = (e = this, t = arguments[0], r = t.sdp, Object.keys(e._reverseStreams || []).forEach(function (t) { const n = e._reverseStreams[t]; const i = e._streams[n.id]; r = r.replace(RegExp(n.id, 'g'), i.id); }), new RTCSessionDescription({ type: t.type, sdp: r })), o.apply(this, arguments)) : o.apply(this, arguments); }; const a = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, 'localDescription'); Object.defineProperty(e.RTCPeerConnection.prototype, 'localDescription', { get: function () { const e = a.get.apply(this); return e.type === '' ? e : s(this, e); } }), e.RTCPeerConnection.prototype.removeTrack = function (e) { const t = this; if (this.signalingState === 'closed') throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", 'InvalidStateError'); if (!e._pc) throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.', 'TypeError'); if (e._pc !== this) throw new DOMException('Sender was not created by this connection.', 'InvalidAccessError'); this._streams = this._streams || {}; let r = void 0; Object.keys(this._streams).forEach(function (n) { t._streams[n].getTracks().find(function (t) { return e.track === t; }) && (r = t._streams[n]); }), r && (r.getTracks().length === 1 ? this.removeStream(this._reverseStreams[r.id]) : r.removeTrack(e.track), this.dispatchEvent(new Event('negotiationneeded'))); }; } function s (e, t) { let r = t.sdp; return Object.keys(e._reverseStreams || []).forEach(function (t) { const n = e._reverseStreams[t]; const i = e._streams[n.id]; r = r.replace(RegExp(i.id, 'g'), n.id); }), new RTCSessionDescription({ type: t.type, sdp: r }); } }, r.shimPeerConnection = function (e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (t) { const r = e.RTCPeerConnection.prototype[t]; const n = c({}, t, function () { return arguments[0] = new (t === 'addIceCandidate' ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments); }); e.RTCPeerConnection.prototype[t] = n[t]; }); }, r.fixNegotiationNeeded = function (e, t) { s.wrapPeerConnectionEvent(e, 'negotiationneeded', function (e) { const r = e.target; if (!(t.version < 72) && (!r.getConfiguration || r.getConfiguration().sdpSemantics !== 'plan-b') || r.signalingState === 'stable') return e; }); }; let a; var s = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils.js'))); function c (e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e; } function p (e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { const e = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(function (t) { return e._shimmedLocalStreams[t][0]; }); }; const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, r) { if (!r) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; const n = t.apply(this, arguments); return this._shimmedLocalStreams[r.id] ? this._shimmedLocalStreams[r.id].indexOf(n) === -1 && this._shimmedLocalStreams[r.id].push(n) : this._shimmedLocalStreams[r.id] = [r, n], n; }; const r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { const t = this; this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(function (e) { if (t.getSenders().find(function (t) { return t.track === e; })) throw new DOMException('Track already exists.', 'InvalidAccessError'); }); const n = this.getSenders(); r.apply(this, arguments); const i = this.getSenders().filter(function (e) { return n.indexOf(e) === -1; }); this._shimmedLocalStreams[e.id] = [e].concat(i); }; const n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], n.apply(this, arguments); }; const i = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { const t = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(function (r) { const n = t._shimmedLocalStreams[r].indexOf(e); n !== -1 && t._shimmedLocalStreams[r].splice(n, 1), t._shimmedLocalStreams[r].length === 1 && delete t._shimmedLocalStreams[r]; }), i.apply(this, arguments); }; } }, { '../utils.js': 11, './getdisplaymedia': 4, './getusermedia': 5 }], 4: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = function (e, t) { if ((!e.navigator.mediaDevices || !('getDisplayMedia' in e.navigator.mediaDevices)) && e.navigator.mediaDevices) { if (typeof t !== 'function') { console.error('shimGetDisplayMedia: getSourceId argument is not a function'); return; }e.navigator.mediaDevices.getDisplayMedia = function (r) { return t(r).then(function (t) { const n = r.video && r.video.width; const i = r.video && r.video.height; const o = r.video && r.video.frameRate; return r.video = { mandatory: { chromeMediaSource: 'desktop', chromeMediaSourceId: t, maxFrameRate: o || 3 } }, n && (r.video.mandatory.maxWidth = n), i && (r.video.mandatory.maxHeight = i), e.navigator.mediaDevices.getUserMedia(r); }); }; } }; }, {}], 5: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.shimGetUserMedia = function (e, t) { const r = e && e.navigator; if (r.mediaDevices) { const i = function (e) { if ((void 0 === e ? 'undefined' : n(e)) !== 'object' || e.mandatory || e.optional) return e; const t = {}; return Object.keys(e).forEach(function (r) { if (r !== 'require' && r !== 'advanced' && r !== 'mediaSource') { const i = n(e[r]) === 'object' ? e[r] : { ideal: e[r] }; void 0 !== i.exact && typeof i.exact === 'number' && (i.min = i.max = i.exact); const o = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : t === 'deviceId' ? 'sourceId' : t; }; if (void 0 !== i.ideal) { t.optional = t.optional || []; let a = {}; typeof i.ideal === 'number' ? (a[o('min', r)] = i.ideal, t.optional.push(a), (a = {})[o('max', r)] = i.ideal, t.optional.push(a)) : (a[o('', r)] = i.ideal, t.optional.push(a)); } void 0 !== i.exact && typeof i.exact !== 'number' ? (t.mandatory = t.mandatory || {}, t.mandatory[o('', r)] = i.exact) : ['min', 'max'].forEach(function (e) { void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[o(e, r)] = i[e]); }); } }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t; }; const o = function (e, o) { if (t.version >= 61) return o(e); if ((e = JSON.parse(JSON.stringify(e))) && n(e.audio) === 'object') { const s = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]); }; s((e = JSON.parse(JSON.stringify(e))).audio, 'autoGainControl', 'googAutoGainControl'), s(e.audio, 'noiseSuppression', 'googNoiseSuppression'), e.audio = i(e.audio); } if (e && n(e.video) === 'object') { let c = e.video.facingMode; c = c && ((void 0 === c ? 'undefined' : n(c)) === 'object' ? c : { ideal: c }); const p = t.version < 66; if (c && (c.exact === 'user' || c.exact === 'environment' || c.ideal === 'user' || c.ideal === 'environment') && !(r.mediaDevices.getSupportedConstraints && r.mediaDevices.getSupportedConstraints().facingMode && !p)) { delete e.video.facingMode; let d = void 0; if (c.exact === 'environment' || c.ideal === 'environment' ? d = ['back', 'rear'] : (c.exact === 'user' || c.ideal === 'user') && (d = ['front']), d) return r.mediaDevices.enumerateDevices().then(function (t) { let r = (t = t.filter(function (e) { return e.kind === 'videoinput'; })).find(function (e) { return d.some(function (t) { return e.label.toLowerCase().includes(t); }); }); return !r && t.length && d.includes('back') && (r = t[t.length - 1]), r && (e.video.deviceId = c.exact ? { exact: r.deviceId } : { ideal: r.deviceId }), e.video = i(e.video), a('chrome: ' + JSON.stringify(e)), o(e); }); }e.video = i(e.video); } return a('chrome: ' + JSON.stringify(e)), o(e); }; const s = function (e) { return t.version >= 64 ? e : { name: ({ PermissionDeniedError: 'NotAllowedError', PermissionDismissedError: 'NotAllowedError', InvalidStateError: 'NotAllowedError', DevicesNotFoundError: 'NotFoundError', ConstraintNotSatisfiedError: 'OverconstrainedError', TrackStartError: 'NotReadableError', MediaDeviceFailedDueToShutdown: 'NotAllowedError', MediaDeviceKillSwitchOn: 'NotAllowedError', TabCaptureError: 'AbortError', ScreenCaptureError: 'AbortError', DeviceCaptureError: 'AbortError' })[e.name] || e.name, message: e.message, constraint: e.constraint || e.constraintName, toString: function () { return this.name + (this.message && ': ') + this.message; } }; }; const c = function (e, t, n) { o(e, function (e) { r.webkitGetUserMedia(e, t, function (e) { n && n(s(e)); }); }); }; if (r.getUserMedia = c.bind(r), r.mediaDevices.getUserMedia) { const p = r.mediaDevices.getUserMedia.bind(r.mediaDevices); r.mediaDevices.getUserMedia = function (e) { return o(e, function (e) { return p(e).then(function (t) { if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach(function (e) { e.stop(); }), new DOMException('', 'NotFoundError'); return t; }, function (e) { return Promise.reject(s(e)); }); }); }; } } }; let i; let o; var a = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils.js'))).log; }, { '../utils.js': 11 }], 6: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }); let n; const i = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.shimRTCIceCandidate = function (e) { if (e.RTCIceCandidate && (!e.RTCIceCandidate || !('foundation' in e.RTCIceCandidate.prototype))) { const t = e.RTCIceCandidate; e.RTCIceCandidate = function (e) { if ((void 0 === e ? 'undefined' : i(e)) === 'object' && e.candidate && e.candidate.indexOf('a=') === 0 && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) { let r; const n = Object.assign(new t(e), s.default.parseCandidate(e.candidate)); return n.toJSON = function () { return { candidate: n.candidate, sdpMid: n.sdpMid, sdpMLineIndex: n.sdpMLineIndex, usernameFragment: n.usernameFragment }; }, n; } return new t(e); }, e.RTCIceCandidate.prototype = t.prototype, c.wrapPeerConnectionEvent(e, 'icecandidate', function (t) { return t.candidate && Object.defineProperty(t, 'candidate', { value: new e.RTCIceCandidate(t.candidate), writable: 'false' }), t; }); } }, r.shimMaxMessageSize = function (e, t) { if (e.RTCPeerConnection) { 'sctp' in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, 'sctp', { get: function () { return void 0 === this._sctp ? null : this._sctp; } }); const r = function (e) { if (!e || !e.sdp) return !1; const t = s.default.splitSections(e.sdp); return t.shift(), t.some(function (e) { const t = s.default.parseMLine(e); return t && t.kind === 'application' && t.protocol.indexOf('SCTP') !== -1; }); }; const n = function (e) { const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (t === null || t.length < 2) return -1; const r = parseInt(t[1], 10); return r != r ? -1 : r; }; const i = function (e) { let r = 65536; return t.browser === 'firefox' && (r = t.version < 57 ? e === -1 ? 16384 : 2147483637 : t.version < 60 ? t.version === 57 ? 65535 : 65536 : 2147483637), r; }; const o = function (e, r) { let n = 65536; t.browser === 'firefox' && t.version === 57 && (n = 65535); const i = s.default.matchPrefix(e.sdp, 'a=max-message-size:'); return i.length > 0 ? n = parseInt(i[0].substr(19), 10) : t.browser === 'firefox' && r !== -1 && (n = 2147483637), n; }; const a = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, t.browser === 'chrome' && t.version >= 76 && this.getConfiguration().sdpSemantics === 'plan-b' && Object.defineProperty(this, 'sctp', { get: function () { return void 0 === this._sctp ? null : this._sctp; }, enumerable: !0, configurable: !0 }), r(arguments[0])) { const e = n(arguments[0]); const s = i(e); const c = o(arguments[0], e); let p = void 0; p = s === 0 && c === 0 ? Number.POSITIVE_INFINITY : s === 0 || c === 0 ? Math.max(s, c) : Math.min(s, c); const d = {}; Object.defineProperty(d, 'maxMessageSize', { get: function () { return p; } }), this._sctp = d; } return a.apply(this, arguments); }; } }, r.shimSendThrowTypeError = function (e) { if (e.RTCPeerConnection && 'createDataChannel' in e.RTCPeerConnection.prototype) { const t = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { const e = t.apply(this, arguments); return r(e, this), e; }, c.wrapPeerConnectionEvent(e, 'datachannel', function (e) { return r(e.channel, e.target), e; }); } function r (e, t) { const r = e.send; e.send = function () { const n = arguments[0]; const i = n.length || n.size || n.byteLength; if (e.readyState === 'open' && t.sctp && i > t.sctp.maxMessageSize) throw TypeError('Message too large (can send a maximum of ' + t.sctp.maxMessageSize + ' bytes)'); return r.apply(e, arguments); }; } }, r.shimConnectionState = function (e) { if (e.RTCPeerConnection && !('connectionState' in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype; Object.defineProperty(t, 'connectionState', { get: function () { return ({ completed: 'connected', checking: 'connecting' })[this.iceConnectionState] || this.iceConnectionState; }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, 'onconnectionstatechange', { get: function () { return this._onconnectionstatechange || null; }, set: function (e) { this._onconnectionstatechange && (this.removeEventListener('connectionstatechange', this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener('connectionstatechange', this._onconnectionstatechange = e); }, enumerable: !0, configurable: !0 }), ['setLocalDescription', 'setRemoteDescription'].forEach(function (e) { const r = t[e]; t[e] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = function (e) { const t = e.target; if (t._lastConnectionState !== t.connectionState) { t._lastConnectionState = t.connectionState; const r = new Event('connectionstatechange', e); t.dispatchEvent(r); } return e; }, this.addEventListener('iceconnectionstatechange', this._connectionstatechangepoly)), r.apply(this, arguments); }; }); } }, r.removeExtmapAllowMixed = function (e, t) { if (e.RTCPeerConnection && (t.browser !== 'chrome' || !(t.version >= 71)) && (t.browser !== 'safari' || !(t.version >= 605))) { const r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (t) { if (t && t.sdp && t.sdp.indexOf('\na=extmap-allow-mixed') !== -1) { const n = t.sdp.split('\n').filter(function (e) { return e.trim() !== 'a=extmap-allow-mixed'; }).join('\n'); e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: t.type, sdp: n }) : t.sdp = n; } return r.apply(this, arguments); }; } }, r.shimAddIceCandidateNullOrEmpty = function (e, t) { if (e.RTCPeerConnection && e.RTCPeerConnection.prototype) { const r = e.RTCPeerConnection.prototype.addIceCandidate; r && r.length !== 0 && (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? (t.browser === 'chrome' && t.version < 78 || t.browser === 'firefox' && t.version < 68 || t.browser === 'safari') && arguments[0] && arguments[0].candidate === '' ? Promise.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()); }); } }, r.shimParameterlessSetLocalDescription = function (e, t) { if (e.RTCPeerConnection && e.RTCPeerConnection.prototype) { const r = e.RTCPeerConnection.prototype.setLocalDescription; r && r.length !== 0 && (e.RTCPeerConnection.prototype.setLocalDescription = function () { const e = this; let t = arguments[0] || {}; if ((void 0 === t ? 'undefined' : i(t)) !== 'object' || t.type && t.sdp) return r.apply(this, arguments); if (!(t = { type: t.type, sdp: t.sdp }).type) switch (this.signalingState) { case 'stable':case 'have-local-offer':case 'have-remote-pranswer':t.type = 'offer'; break; default:t.type = 'answer'; } return t.sdp || t.type !== 'offer' && t.type !== 'answer' ? r.apply(this, [t]) : (t.type === 'offer' ? this.createOffer : this.createAnswer).apply(this).then(function (t) { return r.apply(e, [t]); }); }); } }; let o; let a; var s = (n = e('sdp'), n && n.__esModule ? n : { default: n }); var c = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('./utils'))); }, { './utils': 11, sdp: 12 }], 7: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = r.shimGetUserMedia = void 0; const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; const i = e('./getusermedia'); Object.defineProperty(r, 'shimGetUserMedia', { enumerable: !0, get: function () { return i.shimGetUserMedia; } }); const o = e('./getdisplaymedia'); Object.defineProperty(r, 'shimGetDisplayMedia', { enumerable: !0, get: function () { return o.shimGetDisplayMedia; } }), r.shimOnTrack = function (e) { (void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCTrackEvent && 'receiver' in e.RTCTrackEvent.prototype && !('transceiver' in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get: function () { return { receiver: this.receiver }; } }); }, r.shimPeerConnection = function (e, t) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && (e.RTCPeerConnection || e.mozRTCPeerConnection)) { !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach(function (t) { let r; let n; let i; const o = e.RTCPeerConnection.prototype[t]; const a = (r = {}, n = t, i = function () { return arguments[0] = new (t === 'addIceCandidate' ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), o.apply(this, arguments); }, n in r ? Object.defineProperty(r, n, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[n] = i, r); e.RTCPeerConnection.prototype[t] = a[t]; }); const r = { inboundrtp: 'inbound-rtp', outboundrtp: 'outbound-rtp', candidatepair: 'candidate-pair', localcandidate: 'local-candidate', remotecandidate: 'remote-candidate' }; const i = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { const e = Array.prototype.slice.call(arguments); const n = e[0]; const o = e[1]; const a = e[2]; return i.apply(this, [n || null]).then(function (e) { if (t.version < 53 && !o) try { e.forEach(function (e) { e.type = r[e.type] || e.type; }); } catch (n) { if (n.name !== 'TypeError') throw n; e.forEach(function (t, n) { e.set(n, Object.assign({}, t, { type: r[t.type] || t.type })); }); } return e; }).then(o, a); }; } }, r.shimSenderGetStats = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && e.RTCRtpSender && (!e.RTCRtpSender || !('getStats' in e.RTCRtpSender.prototype))) { const t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { const e = this; const r = t.apply(this, []); return r.forEach(function (t) { return t._pc = e; }), r; }); const r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { const e = r.apply(this, arguments); return e._pc = this, e; }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map()); }; } }, r.shimReceiverGetStats = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && e.RTCRtpSender && (!e.RTCRtpSender || !('getStats' in e.RTCRtpReceiver.prototype))) { const t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { const e = this; const r = t.apply(this, []); return r.forEach(function (t) { return t._pc = e; }), r; }), s.wrapPeerConnectionEvent(e, 'track', function (e) { return e.receiver._pc = e.srcElement, e; }), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track); }; } }, r.shimRemoveStream = function (e) { e.RTCPeerConnection && !('removeStream' in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function (e) { const t = this; s.deprecated('removeStream', 'removeTrack'), this.getSenders().forEach(function (r) { r.track && e.getTracks().includes(r.track) && t.removeTrack(r); }); }); }, r.shimRTCDataChannel = function (e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel); }, r.shimAddTransceiver = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection) { const t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; const e = arguments[1]; const r = e && 'sendEncodings' in e; r && e.sendEncodings.forEach(function (e) { if ('rid' in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw TypeError('Invalid RID value provided.'); if ('scaleResolutionDownBy' in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw RangeError('scale_resolution_down_by must be >= 1.0'); if ('maxFramerate' in e && !(parseFloat(e.maxFramerate) >= 0)) throw RangeError('max_framerate must be >= 0.0'); }); const n = t.apply(this, arguments); if (r) { const i = n.sender; const o = i.getParameters(); 'encodings' in o && (o.encodings.length !== 1 || Object.keys(o.encodings[0]).length !== 0) || (o.encodings = e.sendEncodings, i.sendEncodings = e.sendEncodings, this.setParametersPromises.push(i.setParameters(o).then(function () { delete i.sendEncodings; }).catch(function () { delete i.sendEncodings; }))); } return n; }); } }, r.shimGetParameters = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCRtpSender) { const t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { const e = t.apply(this, arguments); return 'encodings' in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e; }); } }, r.shimCreateOffer = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { const e = this; const r = arguments; return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(function () { return t.apply(e, r); }).finally(function () { e.setParametersPromises = []; }) : t.apply(this, arguments); }; } }, r.shimCreateAnswer = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection) { const t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { const e = this; const r = arguments; return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(function () { return t.apply(e, r); }).finally(function () { e.setParametersPromises = []; }) : t.apply(this, arguments); }; } }; let a; var s = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils'))); }, { '../utils': 11, './getdisplaymedia': 8, './getusermedia': 9 }], 8: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }), r.shimGetDisplayMedia = function (e, t) { (!e.navigator.mediaDevices || !('getDisplayMedia' in e.navigator.mediaDevices)) && e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function (r) { if (!(r && r.video)) { const n = new DOMException('getDisplayMedia without video constraints is undefined'); return n.name = 'NotFoundError', n.code = 8, Promise.reject(n); } return !0 === r.video ? r.video = { mediaSource: t } : r.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(r); }); }; }, {}], 9: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.shimGetUserMedia = function (e, t) { const r = e && e.navigator; const i = e && e.MediaStreamTrack; if (r.getUserMedia = function (e, t, n) { o.deprecated('navigator.getUserMedia', 'navigator.mediaDevices.getUserMedia'), r.mediaDevices.getUserMedia(e).then(t, n); }, !(t.version > 55 && 'autoGainControl' in r.mediaDevices.getSupportedConstraints())) { const a = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]); }; const s = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (e) { return (void 0 === e ? 'undefined' : n(e)) === 'object' && n(e.audio) === 'object' && (a((e = JSON.parse(JSON.stringify(e))).audio, 'autoGainControl', 'mozAutoGainControl'), a(e.audio, 'noiseSuppression', 'mozNoiseSuppression')), s(e); }, i && i.prototype.getSettings) { const c = i.prototype.getSettings; i.prototype.getSettings = function () { const e = c.apply(this, arguments); return a(e, 'mozAutoGainControl', 'autoGainControl'), a(e, 'mozNoiseSuppression', 'noiseSuppression'), e; }; } if (i && i.prototype.applyConstraints) { const p = i.prototype.applyConstraints; i.prototype.applyConstraints = function (e) { return this.kind === 'audio' && (void 0 === e ? 'undefined' : n(e)) === 'object' && (a(e = JSON.parse(JSON.stringify(e)), 'autoGainControl', 'mozAutoGainControl'), a(e, 'noiseSuppression', 'mozNoiseSuppression')), p.apply(this, [e]); }; } } }; let i; var o = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils'))); }, { '../utils': 11 }], 10: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.shimLocalStreamsAPI = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection) { if ('getLocalStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams; }), !('addStream' in e.RTCPeerConnection.prototype)) { const t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (e) { const r = this; this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach(function (n) { return t.call(r, n, e); }), e.getVideoTracks().forEach(function (n) { return t.call(r, n, e); }); }, e.RTCPeerConnection.prototype.addTrack = function (e) { for (var r = this, n = arguments.length, i = Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)i[o - 1] = arguments[o]; return i && i.forEach(function (e) { r._localStreams ? r._localStreams.includes(e) || r._localStreams.push(e) : r._localStreams = [e]; }), t.apply(this, arguments); }; }'removeStream' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) { const t = this; this._localStreams || (this._localStreams = []); const r = this._localStreams.indexOf(e); if (r !== -1) { this._localStreams.splice(r, 1); const n = e.getTracks(); this.getSenders().forEach(function (e) { n.includes(e.track) && t.removeTrack(e); }); } }); } }, r.shimRemoteStreamsAPI = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection && ('getRemoteStreams' in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : []; }), !('onaddstream' in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, 'onaddstream', { get: function () { return this._onaddstream; }, set: function (e) { const t = this; this._onaddstream && (this.removeEventListener('addstream', this._onaddstream), this.removeEventListener('track', this._onaddstreampoly)), this.addEventListener('addstream', this._onaddstream = e), this.addEventListener('track', this._onaddstreampoly = function (e) { e.streams.forEach(function (e) { if (t._remoteStreams || (t._remoteStreams = []), !t._remoteStreams.includes(e)) { t._remoteStreams.push(e); const r = new Event('addstream'); r.stream = e, t.dispatchEvent(r); } }); }); } }); const t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { const e = this; return this._onaddstreampoly || this.addEventListener('track', this._onaddstreampoly = function (t) { t.streams.forEach(function (t) { if (e._remoteStreams || (e._remoteStreams = []), !(e._remoteStreams.indexOf(t) >= 0)) { e._remoteStreams.push(t); const r = new Event('addstream'); r.stream = t, e.dispatchEvent(r); } }); }), t.apply(e, arguments); }; } }, r.shimCallbacksAPI = function (e) { if ((void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCPeerConnection) { const t = e.RTCPeerConnection.prototype; const r = t.createOffer; const i = t.createAnswer; const o = t.setLocalDescription; const a = t.setRemoteDescription; const s = t.addIceCandidate; t.createOffer = function (e, t) { const n = arguments.length >= 2 ? arguments[2] : arguments[0]; const i = r.apply(this, [n]); return t ? (i.then(e, t), Promise.resolve()) : i; }, t.createAnswer = function (e, t) { const r = arguments.length >= 2 ? arguments[2] : arguments[0]; const n = i.apply(this, [r]); return t ? (n.then(e, t), Promise.resolve()) : n; }; let c = function (e, t, r) { const n = o.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n; }; t.setLocalDescription = c, c = function (e, t, r) { const n = a.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n; }, t.setRemoteDescription = c, c = function (e, t, r) { const n = s.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n; }, t.addIceCandidate = c; } }, r.shimGetUserMedia = function (e) { const t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { const r = t.mediaDevices; const n = r.getUserMedia.bind(r); t.mediaDevices.getUserMedia = function (e) { return n(a(e)); }; }!t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, r, n) { t.mediaDevices.getUserMedia(e).then(r, n); }); }, r.shimConstraints = a, r.shimRTCIceServerUrls = function (e) { if (e.RTCPeerConnection) { const t = e.RTCPeerConnection; e.RTCPeerConnection = function (e, r) { if (e && e.iceServers) { for (var n = [], i = 0; i < e.iceServers.length; i++) { let a = e.iceServers[i]; !a.hasOwnProperty('urls') && a.hasOwnProperty('url') ? (o.deprecated('RTCIceServer.url', 'RTCIceServer.urls'), (a = JSON.parse(JSON.stringify(a))).urls = a.url, delete a.url, n.push(a)) : n.push(e.iceServers[i]); }e.iceServers = n; } return new t(e, r); }, e.RTCPeerConnection.prototype = t.prototype, 'generateCertificate' in t && Object.defineProperty(e.RTCPeerConnection, 'generateCertificate', { get: function () { return t.generateCertificate; } }); } }, r.shimTrackEventTransceiver = function (e) { (void 0 === e ? 'undefined' : n(e)) === 'object' && e.RTCTrackEvent && 'receiver' in e.RTCTrackEvent.prototype && !('transceiver' in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, 'transceiver', { get: function () { return { receiver: this.receiver }; } }); }, r.shimCreateOfferLegacy = function (e) { const t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (e) { if (e) { void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio); const r = this.getTransceivers().find(function (e) { return e.receiver.track.kind === 'audio'; }); !1 === e.offerToReceiveAudio && r ? r.direction === 'sendrecv' ? r.setDirection ? r.setDirection('sendonly') : r.direction = 'sendonly' : r.direction === 'recvonly' && (r.setDirection ? r.setDirection('inactive') : r.direction = 'inactive') : !0 !== e.offerToReceiveAudio || r || this.addTransceiver('audio'), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo); const n = this.getTransceivers().find(function (e) { return e.receiver.track.kind === 'video'; }); !1 === e.offerToReceiveVideo && n ? n.direction === 'sendrecv' ? n.setDirection ? n.setDirection('sendonly') : n.direction = 'sendonly' : n.direction === 'recvonly' && (n.setDirection ? n.setDirection('inactive') : n.direction = 'inactive') : !0 !== e.offerToReceiveVideo || n || this.addTransceiver('video'); } return t.apply(this, arguments); }; }, r.shimAudioContext = function (e) { (void 0 === e ? 'undefined' : n(e)) === 'object' && !e.AudioContext && (e.AudioContext = e.webkitAudioContext); }; let i; var o = (function (e) { if (e && e.__esModule) return e; const t = {}; if (e != null) for (const r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]); return t.default = e, t; }(e('../utils'))); function a (e) { return e && void 0 !== e.video ? Object.assign({}, e, { video: o.compactObject(e.video) }) : e; } }, { '../utils': 11 }], 11: [function (e, t, r) { 'use strict'; Object.defineProperty(r, '__esModule', { value: !0 }); const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; r.extractVersion = a, r.wrapPeerConnectionEvent = function (e, t, r) { if (e.RTCPeerConnection) { const n = e.RTCPeerConnection.prototype; const i = n.addEventListener; n.addEventListener = function (e, n) { if (e !== t) return i.apply(this, arguments); const o = function (e) { const t = r(e); t && (n.handleEvent ? n.handleEvent(t) : n(t)); }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map()), this._eventMap[t].set(n, o), i.apply(this, [e, o]); }; const o = n.removeEventListener; n.removeEventListener = function (e, r) { if (e !== t || !this._eventMap || !this._eventMap[t] || !this._eventMap[t].has(r)) return o.apply(this, arguments); const n = this._eventMap[t].get(r); return this._eventMap[t].delete(r), this._eventMap[t].size === 0 && delete this._eventMap[t], Object.keys(this._eventMap).length === 0 && delete this._eventMap, o.apply(this, [e, n]); }, Object.defineProperty(n, 'on' + t, { get: function () { return this['_on' + t]; }, set: function (e) { this['_on' + t] && (this.removeEventListener(t, this['_on' + t]), delete this['_on' + t]), e && this.addEventListener(t, this['_on' + t] = e); }, enumerable: !0, configurable: !0 }); } }, r.disableLog = function (e) { return typeof e !== 'boolean' ? Error('Argument type: ' + (void 0 === e ? 'undefined' : n(e)) + '. Please use a boolean.') : (i = e, e ? 'adapter.js logging disabled' : 'adapter.js logging enabled'); }, r.disableWarnings = function (e) { return typeof e !== 'boolean' ? Error('Argument type: ' + (void 0 === e ? 'undefined' : n(e)) + '. Please use a boolean.') : (o = !e, 'adapter.js deprecation warnings ' + (e ? 'disabled' : 'enabled')); }, r.log = function () { (typeof window === 'undefined' ? 'undefined' : n(window)) === 'object' && !i && typeof console !== 'undefined' && typeof console.log === 'function' && console.log.apply(console, arguments); }, r.deprecated = function (e, t) { o && console.warn(e + ' is deprecated, please use ' + t + ' instead.'); }, r.detectBrowser = function (e) { const t = { browser: null, version: null }; if (void 0 === e || !e.navigator) return t.browser = 'Not a browser.', t; const r = e.navigator; return r.mozGetUserMedia ? (t.browser = 'firefox', t.version = a(r.userAgent, /Firefox\/(\d+)\./, 1)) : r.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer ? (t.browser = 'chrome', t.version = a(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2)) : e.RTCPeerConnection && r.userAgent.match(/AppleWebKit\/(\d+)\./) ? (t.browser = 'safari', t.version = a(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && 'currentDirection' in e.RTCRtpTransceiver.prototype) : t.browser = 'Not a supported browser.', t; }, r.compactObject = function e (t) { return s(t) ? Object.keys(t).reduce(function (r, n) { let i; let o; let a; const c = s(t[n]); const p = c ? e(t[n]) : t[n]; const d = c && !Object.keys(p).length; return void 0 === p || d ? r : Object.assign(r, (i = {}, o = n, a = p, o in i ? Object.defineProperty(i, o, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : i[o] = a, i)); }, {}) : t; }, r.walkStats = c, r.filterStats = function (e, t, r) { const n = r ? 'outbound-rtp' : 'inbound-rtp'; const i = new Map(); if (t === null) return i; const o = []; return e.forEach(function (e) { e.type === 'track' && e.trackIdentifier === t.id && o.push(e); }), o.forEach(function (t) { e.forEach(function (r) { r.type === n && r.trackId === t.id && c(e, r, i); }); }), i; }; var i = !0; var o = !0; function a (e, t, r) { const n = e.match(t); return n && n.length >= r && parseInt(n[r], 10); } function s (e) { return Object.prototype.toString.call(e) === '[object Object]'; } function c (e, t, r) { !(!t || r.has(t.id)) && (r.set(t.id, t), Object.keys(t).forEach(function (n) { n.endsWith('Id') ? c(e, e.get(t[n]), r) : n.endsWith('Ids') && t[n].forEach(function (t) { c(e, e.get(t), r); }); })); } }, {}], 12: [function (e, t, r) { 'use strict'; const n = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; const i = {}; i.generateIdentifier = function () { return Math.random().toString(36).substr(2, 10); }, i.localCName = i.generateIdentifier(), i.splitLines = function (e) { return e.trim().split('\n').map(function (e) { return e.trim(); }); }, i.splitSections = function (e) { return e.split('\nm=').map(function (e, t) { return (t > 0 ? 'm=' + e : e).trim() + '\r\n'; }); }, i.getDescription = function (e) { const t = i.splitSections(e); return t && t[0]; }, i.getMediaSections = function (e) { const t = i.splitSections(e); return t.shift(), t; }, i.matchPrefix = function (e, t) { return i.splitLines(e).filter(function (e) { return e.indexOf(t) === 0; }); }, i.parseCandidate = function (e) { for (var t = void 0, r = { foundation: (t = e.indexOf('a=candidate:') === 0 ? e.substring(12).split(' ') : e.substring(10).split(' '))[0], component: { 1: 'rtp', 2: 'rtcp' }[t[1]] || t[1], protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], address: t[4], port: parseInt(t[5], 10), type: t[7] }, n = 8; n < t.length; n += 2) switch (t[n]) { case 'raddr':r.relatedAddress = t[n + 1]; break; case 'rport':r.relatedPort = parseInt(t[n + 1], 10); break; case 'tcptype':r.tcpType = t[n + 1]; break; case 'ufrag':r.ufrag = t[n + 1], r.usernameFragment = t[n + 1]; break; default:void 0 === r[t[n]] && (r[t[n]] = t[n + 1]); } return r; }, i.writeCandidate = function (e) { const t = []; t.push(e.foundation); const r = e.component; r === 'rtp' ? t.push(1) : r === 'rtcp' ? t.push(2) : t.push(r), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port); const n = e.type; return t.push('typ'), t.push(n), n !== 'host' && e.relatedAddress && e.relatedPort && (t.push('raddr'), t.push(e.relatedAddress), t.push('rport'), t.push(e.relatedPort)), e.tcpType && e.protocol.toLowerCase() === 'tcp' && (t.push('tcptype'), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push('ufrag'), t.push(e.usernameFragment || e.ufrag)), 'candidate:' + t.join(' '); }, i.parseIceOptions = function (e) { return e.substr(14).split(' '); }, i.parseRtpMap = function (e) { let t = e.substr(9).split(' '); const r = { payloadType: parseInt(t.shift(), 10) }; return t = t[0].split('/'), r.name = t[0], r.clockRate = parseInt(t[1], 10), r.channels = t.length === 3 ? parseInt(t[2], 10) : 1, r.numChannels = r.channels, r; }, i.writeRtpMap = function (e) { let t = e.payloadType; void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType); const r = e.channels || e.numChannels || 1; return 'a=rtpmap:' + t + ' ' + e.name + '/' + e.clockRate + (r !== 1 ? '/' + r : '') + '\r\n'; }, i.parseExtmap = function (e) { const t = e.substr(9).split(' '); return { id: parseInt(t[0], 10), direction: t[0].indexOf('/') > 0 ? t[0].split('/')[1] : 'sendrecv', uri: t[1] }; }, i.writeExtmap = function (e) { return 'a=extmap:' + (e.id || e.preferredId) + (e.direction && e.direction !== 'sendrecv' ? '/' + e.direction : '') + ' ' + e.uri + '\r\n'; }, i.parseFmtp = function (e) { for (var t = {}, r = void 0, n = e.substr(e.indexOf(' ') + 1).split(';'), i = 0; i < n.length; i++)t[(r = n[i].trim().split('='))[0].trim()] = r[1]; return t; }, i.writeFmtp = function (e) { let t = ''; let r = e.payloadType; if (void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { const n = []; Object.keys(e.parameters).forEach(function (t) { void 0 !== e.parameters[t] ? n.push(t + '=' + e.parameters[t]) : n.push(t); }), t += 'a=fmtp:' + r + ' ' + n.join(';') + '\r\n'; } return t; }, i.parseRtcpFb = function (e) { const t = e.substr(e.indexOf(' ') + 1).split(' '); return { type: t.shift(), parameter: t.join(' ') }; }, i.writeRtcpFb = function (e) { let t = ''; let r = e.payloadType; return void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(function (e) { t += 'a=rtcp-fb:' + r + ' ' + e.type + (e.parameter && e.parameter.length ? ' ' + e.parameter : '') + '\r\n'; }), t; }, i.parseSsrcMedia = function (e) { const t = e.indexOf(' '); const r = { ssrc: parseInt(e.substr(7, t - 7), 10) }; const n = e.indexOf(':', t); return n > -1 ? (r.attribute = e.substr(t + 1, n - t - 1), r.value = e.substr(n + 1)) : r.attribute = e.substr(t + 1), r; }, i.parseSsrcGroup = function (e) { const t = e.substr(13).split(' '); return { semantics: t.shift(), ssrcs: t.map(function (e) { return parseInt(e, 10); }) }; }, i.getMid = function (e) { const t = i.matchPrefix(e, 'a=mid:')[0]; if (t) return t.substr(6); }, i.parseFingerprint = function (e) { const t = e.substr(14).split(' '); return { algorithm: t[0].toLowerCase(), value: t[1].toUpperCase() }; }, i.getDtlsParameters = function (e, t) { return { role: 'auto', fingerprints: i.matchPrefix(e + t, 'a=fingerprint:').map(i.parseFingerprint) }; }, i.writeDtlsParameters = function (e, t) { let r = 'a=setup:' + t + '\r\n'; return e.fingerprints.forEach(function (e) { r += 'a=fingerprint:' + e.algorithm + ' ' + e.value + '\r\n'; }), r; }, i.parseCryptoLine = function (e) { const t = e.substr(9).split(' '); return { tag: parseInt(t[0], 10), cryptoSuite: t[1], keyParams: t[2], sessionParams: t.slice(3) }; }, i.writeCryptoLine = function (e) { return 'a=crypto:' + e.tag + ' ' + e.cryptoSuite + ' ' + (n(e.keyParams) === 'object' ? i.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? ' ' + e.sessionParams.join(' ') : '') + '\r\n'; }, i.parseCryptoKeyParams = function (e) { if (e.indexOf('inline:') !== 0) return null; const t = e.substr(7).split('|'); return { keyMethod: 'inline', keySalt: t[0], lifeTime: t[1], mkiValue: t[2] ? t[2].split(':')[0] : void 0, mkiLength: t[2] ? t[2].split(':')[1] : void 0 }; }, i.writeCryptoKeyParams = function (e) { return e.keyMethod + ':' + e.keySalt + (e.lifeTime ? '|' + e.lifeTime : '') + (e.mkiValue && e.mkiLength ? '|' + e.mkiValue + ':' + e.mkiLength : ''); }, i.getCryptoParameters = function (e, t) { return i.matchPrefix(e + t, 'a=crypto:').map(i.parseCryptoLine); }, i.getIceParameters = function (e, t) { const r = i.matchPrefix(e + t, 'a=ice-ufrag:')[0]; const n = i.matchPrefix(e + t, 'a=ice-pwd:')[0]; return r && n ? { usernameFragment: r.substr(12), password: n.substr(10) } : null; }, i.writeIceParameters = function (e) { let t = 'a=ice-ufrag:' + e.usernameFragment + '\r\na=ice-pwd:' + e.password + '\r\n'; return e.iceLite && (t += 'a=ice-lite\r\n'), t; }, i.parseRtpParameters = function (e) { for (var t = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = i.splitLines(e)[0].split(' '), n = 3; n < r.length; n++) { const o = r[n]; const a = i.matchPrefix(e, 'a=rtpmap:' + o + ' ')[0]; if (a) { const s = i.parseRtpMap(a); const c = i.matchPrefix(e, 'a=fmtp:' + o + ' '); switch (s.parameters = c.length ? i.parseFmtp(c[0]) : {}, s.rtcpFeedback = i.matchPrefix(e, 'a=rtcp-fb:' + o + ' ').map(i.parseRtcpFb), t.codecs.push(s), s.name.toUpperCase()) { case 'RED':case 'ULPFEC':t.fecMechanisms.push(s.name.toUpperCase()); } } } return i.matchPrefix(e, 'a=extmap:').forEach(function (e) { t.headerExtensions.push(i.parseExtmap(e)); }), t; }, i.writeRtpDescription = function (e, t) { let r = ''; r += 'm=' + e + ' ', r += t.codecs.length > 0 ? '9' : '0', r += ' UDP/TLS/RTP/SAVPF ', r += t.codecs.map(function (e) { return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType; }).join(' ') + '\r\n', r += 'c=IN IP4 0.0.0.0\r\n', r += 'a=rtcp:9 IN IP4 0.0.0.0\r\n', t.codecs.forEach(function (e) { r += i.writeRtpMap(e), r += i.writeFmtp(e), r += i.writeRtcpFb(e); }); let n = 0; return t.codecs.forEach(function (e) { e.maxptime > n && (n = e.maxptime); }), n > 0 && (r += 'a=maxptime:' + n + '\r\n'), t.headerExtensions && t.headerExtensions.forEach(function (e) { r += i.writeExtmap(e); }), r; }, i.parseRtpEncodingParameters = function (e) { const t = []; const r = i.parseRtpParameters(e); const n = r.fecMechanisms.indexOf('RED') !== -1; const o = r.fecMechanisms.indexOf('ULPFEC') !== -1; const a = i.matchPrefix(e, 'a=ssrc:').map(function (e) { return i.parseSsrcMedia(e); }).filter(function (e) { return e.attribute === 'cname'; }); const s = a.length > 0 && a[0].ssrc; let c = void 0; const p = i.matchPrefix(e, 'a=ssrc-group:FID').map(function (e) { return e.substr(17).split(' ').map(function (e) { return parseInt(e, 10); }); }); p.length > 0 && p[0].length > 1 && p[0][0] === s && (c = p[0][1]), r.codecs.forEach(function (e) { if (e.name.toUpperCase() === 'RTX' && e.parameters.apt) { let r = { ssrc: s, codecPayloadType: parseInt(e.parameters.apt, 10) }; s && c && (r.rtx = { ssrc: c }), t.push(r), n && ((r = JSON.parse(JSON.stringify(r))).fec = { ssrc: s, mechanism: o ? 'red+ulpfec' : 'red' }, t.push(r)); } }), t.length === 0 && s && t.push({ ssrc: s }); let d = i.matchPrefix(e, 'b='); return d.length && (d = d[0].indexOf('b=TIAS:') === 0 ? parseInt(d[0].substr(7), 10) : d[0].indexOf('b=AS:') === 0 ? 950 * parseInt(d[0].substr(5), 10) - 16e3 : void 0, t.forEach(function (e) { e.maxBitrate = d; })), t; }, i.parseRtcpParameters = function (e) { const t = {}; const r = i.matchPrefix(e, 'a=ssrc:').map(function (e) { return i.parseSsrcMedia(e); }).filter(function (e) { return e.attribute === 'cname'; })[0]; r && (t.cname = r.value, t.ssrc = r.ssrc); const n = i.matchPrefix(e, 'a=rtcp-rsize'); t.reducedSize = n.length > 0, t.compound = n.length === 0; const o = i.matchPrefix(e, 'a=rtcp-mux'); return t.mux = o.length > 0, t; }, i.writeRtcpParameters = function (e) { let t = ''; return e.reducedSize && (t += 'a=rtcp-rsize\r\n'), e.mux && (t += 'a=rtcp-mux\r\n'), void 0 !== e.ssrc && e.cname && (t += 'a=ssrc:' + e.ssrc + ' cname:' + e.cname + '\r\n'), t; }, i.parseMsid = function (e) { let t = void 0; const r = i.matchPrefix(e, 'a=msid:'); if (r.length === 1) return { stream: (t = r[0].substr(7).split(' '))[0], track: t[1] }; const n = i.matchPrefix(e, 'a=ssrc:').map(function (e) { return i.parseSsrcMedia(e); }).filter(function (e) { return e.attribute === 'msid'; }); if (n.length > 0) return { stream: (t = n[0].value.split(' '))[0], track: t[1] }; }, i.parseSctpDescription = function (e) { const t = i.parseMLine(e); const r = i.matchPrefix(e, 'a=max-message-size:'); let n = void 0; r.length > 0 && (n = parseInt(r[0].substr(19), 10)), isNaN(n) && (n = 65536); const o = i.matchPrefix(e, 'a=sctp-port:'); if (o.length > 0) return { port: parseInt(o[0].substr(12), 10), protocol: t.fmt, maxMessageSize: n }; const a = i.matchPrefix(e, 'a=sctpmap:'); if (a.length > 0) { const s = a[0].substr(10).split(' '); return { port: parseInt(s[0], 10), protocol: s[1], maxMessageSize: n }; } }, i.writeSctpDescription = function (e, t) { let r = []; return r = e.protocol !== 'DTLS/SCTP' ? ['m=' + e.kind + ' 9 ' + e.protocol + ' ' + t.protocol + '\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=sctp-port:' + t.port + '\r\n'] : ['m=' + e.kind + ' 9 ' + e.protocol + ' ' + t.port + '\r\n', 'c=IN IP4 0.0.0.0\r\n', 'a=sctpmap:' + t.port + ' ' + t.protocol + ' 65535\r\n'], void 0 !== t.maxMessageSize && r.push('a=max-message-size:' + t.maxMessageSize + '\r\n'), r.join(''); }, i.generateSessionId = function () { return Math.random().toString().substr(2, 21); }, i.writeSessionBoilerplate = function (e, t, r) { let n = void 0; return 'v=0\r\no=' + (r || 'thisisadapterortc') + ' ' + (n = e || i.generateSessionId()) + ' ' + (void 0 !== t ? t : 2) + ' IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n'; }, i.getDirection = function (e, t) { for (let r = i.splitLines(e), n = 0; n < r.length; n++) switch (r[n]) { case 'a=sendrecv':case 'a=sendonly':case 'a=recvonly':case 'a=inactive':return r[n].substr(2); } return t ? i.getDirection(t) : 'sendrecv'; }, i.getKind = function (e) { return i.splitLines(e)[0].split(' ')[0].substr(2); }, i.isRejected = function (e) { return e.split(' ', 2)[1] === '0'; }, i.parseMLine = function (e) { const t = i.splitLines(e)[0].substr(2).split(' '); return { kind: t[0], port: parseInt(t[1], 10), protocol: t[2], fmt: t.slice(3).join(' ') }; }, i.parseOLine = function (e) { const t = i.matchPrefix(e, 'o=')[0].substr(2).split(' '); return { username: t[0], sessionId: t[1], sessionVersion: parseInt(t[2], 10), netType: t[3], addressType: t[4], address: t[5] }; }, i.isValidSDP = function (e) { if (typeof e !== 'string' || e.length === 0) return !1; for (let t = i.splitLines(e), r = 0; r < t.length; r++) if (t[r].length < 2 || t[r].charAt(1) !== '=') return !1; return !0; }, (void 0 === t ? 'undefined' : n(t)) === 'object' && (t.exports = i); }, {}] }, {}, [1])(1); }));
